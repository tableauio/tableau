package protogen

import (
	"path/filepath"
	"regexp"
	"strings"

	"github.com/emirpasic/gods/sets/treeset"
	"github.com/rogpeppe/go-internal/lockedfile"
	"github.com/tableauio/tableau/internal/printer"
	"github.com/tableauio/tableau/internal/strcase"
	"github.com/tableauio/tableau/internal/types"
	"github.com/tableauio/tableau/internal/x/xfs"
	"github.com/tableauio/tableau/internal/x/xproto"
	"github.com/tableauio/tableau/log"
	"github.com/tableauio/tableau/proto/tableaupb"
	"github.com/tableauio/tableau/proto/tableaupb/internalpb"
	"github.com/tableauio/tableau/xerrors"
	"google.golang.org/protobuf/encoding/prototext"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type bookExporter struct {
	ProtoPackage     string
	ProtoFileOptions map[string]string
	OutputDir        string
	FilenameSuffix   string
	wb               *internalpb.Workbook

	gen *Generator

	messagerPatternRegexp *regexp.Regexp
}

func newBookExporter(protoPackage string, protoFileOptions map[string]string, outputDir, filenameSuffix string, wb *internalpb.Workbook, gen *Generator) *bookExporter {
	return &bookExporter{
		ProtoPackage:          protoPackage,
		ProtoFileOptions:      protoFileOptions,
		OutputDir:             outputDir,
		FilenameSuffix:        filenameSuffix,
		wb:                    wb,
		gen:                   gen,
		messagerPatternRegexp: regexp.MustCompile(gen.InputOpt.MessagerPattern),
	}
}

func (x *bookExporter) GetProtoFilePath() string {
	return genProtoFilePath(x.wb.GetName(), x.FilenameSuffix)
}

func (x *bookExporter) export(checkProtoFileConflicts bool) error {
	// log.Debug(proto.MarshalTextString(wb))
	p1 := printer.New()
	p1.P("// Code generated by tableau (protogen v", Version, "). DO NOT EDIT.")
	p1.P("// clang-format off")
	p1.P("")
	p1.P(`syntax = "proto3";`)
	p1.P("")
	p1.P("package ", x.ProtoPackage, ";")
	p1.P("")

	// keep the elements ordered by import path
	set := treeset.NewWithStringComparator()
	set.Add(tableauProtoPath) // default must be imported path
	p3 := printer.New()
	for i, ws := range x.wb.Worksheets {
		se := &sheetExporter{
			be:             x,
			ws:             ws,
			p:              p3,
			isLastSheet:    i == len(x.wb.Worksheets)-1,
			typeInfos:      x.gen.typeInfos,
			nestedMessages: make(map[string]*internalpb.Field),
			Imports:        make(map[string]bool),
		}
		if err := se.export(); err != nil {
			return xerrors.WrapKV(err, xerrors.KeySheetName, ws.Name)
		}
		for key := range se.Imports {
			set.Add(key)
		}
	}

	// generate imports
	p2 := printer.New()
	for _, key := range set.Values() {
		p2.P(`import "`, key, `";`)
	}
	p2.P("")
	for k, v := range x.ProtoFileOptions {
		p2.P(`option `, k, ` = "`, v, `";`)
	}
	p2.P("option (tableau.workbook) = {", marshalToText(x.wb.Options), "};")
	p2.P("")

	relPath := x.GetProtoFilePath()
	path := filepath.Join(x.OutputDir, relPath)
	log.Infof("%15s: %s", "generated proto", relPath)

	// mu := lockedfile.MutexAt(path)
	// unlock, err := mu.Lock()
	// if err != nil {
	// 	return xerrors.Wrapf(err, "failed to lock file: %s", path)
	// }
	// defer unlock()

	// NOTE: use file lock to protect .proto file from being written concurrently by multiple goroutines
	// refer: https://github.com/golang/go/issues/33974
	// refer: https://go.googlesource.com/proposal/+/master/design/33974-add-public-lockedfile-pkg.md

	if checkProtoFileConflicts {
		if existed, err := xfs.Exists(path); err != nil {
			return xerrors.WrapKV(err)
		} else {
			if existed {
				return xerrors.Newf("file already exists: %s", path)
			}
		}
	}

	if f, err := lockedfile.Create(path); err != nil {
		return xerrors.WrapKV(err)
	} else {
		defer func() {
			err := f.Close()
			if err != nil {
				log.Panicf("failed to close file: %s", path)
			}
		}()
		if _, err = f.Write(p1.Bytes()); err != nil {
			return xerrors.WrapKV(err)
		}
		if _, err = f.Write(p2.Bytes()); err != nil {
			return xerrors.WrapKV(err)
		}
		if _, err = f.Write(p3.Bytes()); err != nil {
			return xerrors.WrapKV(err)
		}
	}

	return nil
}

type sheetExporter struct {
	be          *bookExporter
	ws          *internalpb.Worksheet
	p           *printer.Printer
	isLastSheet bool
	typeInfos   *xproto.TypeInfos

	Imports        map[string]bool              // import name -> defined
	nestedMessages map[string]*internalpb.Field // top message scoped type name -> field
}

func (x *sheetExporter) export() error {
	mode := x.ws.GetOptions().GetMode()
	switch x.ws.Options.Mode {
	case tableaupb.Mode_MODE_DEFAULT:
		return x.exportMessager()
	case tableaupb.Mode_MODE_ENUM_TYPE, tableaupb.Mode_MODE_ENUM_TYPE_MULTI:
		return x.exportEnum()
	case tableaupb.Mode_MODE_STRUCT_TYPE, tableaupb.Mode_MODE_STRUCT_TYPE_MULTI:
		return x.exportStruct()
	case tableaupb.Mode_MODE_UNION_TYPE, tableaupb.Mode_MODE_UNION_TYPE_MULTI:
		return x.exportUnion()
	default:
		return xerrors.Newf("unknown mode: %v", mode)
	}
}

func (x *sheetExporter) exportEnum() error {
	if x.ws.Note != "" {
		x.p.P("// ", x.ws.Note)
	}
	x.p.P("enum ", x.ws.Name, " {")
	opts := &tableaupb.EnumOptions{Name: x.ws.GetOptions().GetName(), Note: x.ws.Note}
	x.p.P("  option (tableau.etype) = {", marshalToText(opts), "};")
	x.p.P("")
	// generate the enum value fields
	for i, field := range x.ws.Fields {
		if i == 0 && field.Number != 0 {
			ename := strcase.FromContext(x.be.gen.ctx).ToScreamingSnake(x.ws.Name) + "_INVALID"
			x.p.P("  ", ename, " = 0;")
		}
		if field.Number == 0 && i != 0 {
			return xerrors.Newf("zero enum value must be the first one, but found at enum value row: %d", i+1)
		}
		note := ""
		if field.Alias != "" {
			note = " // " + field.Alias
		}
		x.p.P("  ", strings.TrimSpace(field.Name), " = ", field.Number, ` [(tableau.evalue).name = "`, strings.TrimSpace(field.Alias), `"];`, note)
	}
	x.p.P("}")
	if !x.isLastSheet {
		x.p.P("")
	}
	return nil
}

func (x *sheetExporter) exportStruct() error {
	x.p.P("message ", x.ws.Name, " {")
	opts := &tableaupb.StructOptions{Name: x.ws.GetOptions().GetName(), Note: x.ws.Note}
	x.p.P("  option (tableau.struct) = {", marshalToText(opts), "};")
	x.p.P("")

	oldMD := x.findMDFromGeneratedProtos(x.ws.Name)
	x.assignFieldNumbers(x.ws.Fields, oldMD)
	// generate the fields
	depth := 1
	for _, field := range x.ws.Fields {
		var fd protoreflect.FieldDescriptor
		if oldMD != nil {
			fd = oldMD.Fields().ByNumber(protoreflect.FieldNumber(field.GetNumber()))
		}
		if err := x.exportField(depth, field, x.ws.Name, fd); err != nil {
			return err
		}
	}
	x.p.P("}")
	if !x.isLastSheet {
		x.p.P("")
	}
	return nil
}

func (x *sheetExporter) exportUnion() error {
	x.p.P("message ", x.ws.Name, " {")
	opts := &tableaupb.UnionOptions{Name: x.ws.GetOptions().GetName(), Note: x.ws.Note}
	x.p.P("  option (tableau.union) = {", marshalToText(opts), "};")
	x.p.P()

	typeOpts := &tableaupb.FieldOptions{Name: "Type"}
	x.p.P("  Type type = 9999 [(tableau.field) = {", marshalToText(typeOpts), "}];")
	x.p.P(`  oneof value {`)

	oneOfOpts := &tableaupb.OneofOptions{Note: x.ws.Note, Field: "Field"}
	x.p.P("    option (tableau.oneof) = {", marshalToText(oneOfOpts), "};")
	x.p.P()

	for _, field := range x.ws.Fields {
		ename := "TYPE_" + strcase.FromContext(x.be.gen.ctx).ToScreamingSnake(field.Name)
		typ := field.Name
		if field.FullType != "" {
			typ = field.FullType
		}
		if len(field.Fields) == 0 && field.Type == "" {
			x.p.P("    // No field bound to enum value: ", ename, ".")
		} else {
			x.p.P("    ", typ, " ", strcase.FromContext(x.be.gen.ctx).ToSnake(field.Name), " = ", field.Number, `; // Bound to enum value: `, ename, ".")
		}
	}
	x.p.P(`  }`)
	x.p.P()

	// generate enum type
	x.p.P("  enum Type {")
	x.p.P("    TYPE_INVALID = 0;")
	for _, field := range x.ws.Fields {
		ename := "TYPE_" + strcase.FromContext(x.be.gen.ctx).ToScreamingSnake(field.Name)
		note := ""
		if field.Alias != "" {
			note = " // " + field.Alias
		}
		x.p.P("    ", ename, " = ", field.Number, ` [(tableau.evalue).name = "`, field.Alias, `"];`, note)
	}
	x.p.P("  }")
	x.p.P()

	// generate message type
	for _, msgField := range x.ws.Fields {
		if len(msgField.Fields) == 0 {
			continue
		}
		typ := msgField.Name
		if msgField.Type != "" {
			typ = msgField.Type
		}
		x.p.P("  message ", typ, " {")
		// generate the fields
		depth := 2
		fieldNumber := int32(1)
		for _, field := range msgField.Fields {
			field.Number = fieldNumber
			cross := max(field.GetOptions().GetProp().GetCross(), 1)
			fieldNumber += cross
		}
		for _, field := range msgField.Fields {
			if err := x.exportField(depth, field, msgField.Name, nil); err != nil {
				return err
			}
		}
		x.p.P("  }")
	}

	x.p.P("}")
	if !x.isLastSheet {
		x.p.P("")
	}
	return nil
}

// findMDFromGeneratedProtos finds the MessageDescriptor in the generated proto
// files by message name. It returns nil if not found.
//
// NOTE: Even if the message is moved to another proto file, we still can find it
// in the generated proto files.
func (x *sheetExporter) findMDFromGeneratedProtos(name string) protoreflect.MessageDescriptor {
	if !x.be.gen.OutputOpt.PreserveFieldNumbers {
		return nil
	}
	fullName := protoreflect.FullName(x.be.ProtoPackage).Append(protoreflect.Name(name))
	descriptor, err := x.be.gen.ProtoRegistryFiles.FindDescriptorByName(fullName)
	if err != nil {
		return nil
	}
	return descriptor.(protoreflect.MessageDescriptor)
}

// assignFieldNumbers assigns the field numbers to the fields. It uses the old
// MD to preserve field numbers if provided, otherwise it assigns field numbers
// in sequence starting from 1.
func (*sheetExporter) assignFieldNumbers(fields []*internalpb.Field, oldMD protoreflect.MessageDescriptor) {
	if oldMD == nil {
		fieldNumber := int32(1)
		for _, field := range fields {
			field.Number = fieldNumber
			fieldNumber++
		}
		return
	}
	fieldNameNumberMap := make(map[string]int32)
	var maxFieldNumber int32
	for i := 0; i < oldMD.Fields().Len(); i++ {
		fd := oldMD.Fields().Get(i)
		for _, field := range fields {
			if string(fd.Name()) == field.Name {
				fieldNameNumberMap[field.Name] = int32(fd.Number())
			}
		}
		maxFieldNumber = max(maxFieldNumber, int32(fd.Number()))
	}
	for _, field := range fields {
		if number, ok := fieldNameNumberMap[field.Name]; ok {
			// for existing field, use the old field number.
			field.Number = number
		} else {
			// for new field, assign the max field number plus 1 in the same level.
			maxFieldNumber++
			field.Number = maxFieldNumber
		}
	}
}

func (x *sheetExporter) exportMessager() error {
	// log.Debugf("workbook: %s", x.ws.String())
	if x.be.messagerPatternRegexp != nil && !x.be.messagerPatternRegexp.MatchString(x.ws.Name) {
		return xerrors.Newf("messager %s does not match pattern %q", x.ws.Name, x.be.messagerPatternRegexp.String())
	}
	x.p.P("message ", x.ws.Name, " {")
	x.p.P("  option (tableau.worksheet) = {", marshalToText(x.ws.Options), "};")
	x.p.P("")

	md := x.findMDFromGeneratedProtos(x.ws.Name)
	x.assignFieldNumbers(x.ws.Fields, md)
	// generate the fields
	depth := 1
	for _, field := range x.ws.Fields {
		var fd protoreflect.FieldDescriptor
		if md != nil {
			fd = md.Fields().ByNumber(protoreflect.FieldNumber(field.GetNumber()))
		}
		if err := x.exportField(depth, field, x.ws.Name, fd); err != nil {
			return err
		}
	}
	x.p.P("}")
	if !x.isLastSheet {
		x.p.P("")
	}
	return nil
}

func (x *sheetExporter) exportField(depth int, field *internalpb.Field, prefix string, oldFD protoreflect.FieldDescriptor) error {
	label := ""
	if x.ws.GetOptions().GetFieldPresence() &&
		types.IsScalarType(field.FullType) &&
		!types.IsWellKnownMessage(field.FullType) {
		label = "optional "
	}
	note := ""
	if field.Note != "" {
		note = " // " + field.Note
	}
	x.p.P(printer.Indent(depth), label, field.FullType, " ", field.Name, " = ", field.Number, " ", genFieldOptionsString(field.Options), ";", note)

	var oldMD protoreflect.MessageDescriptor
	typeName := field.Type
	fullTypeName := field.FullType
	if field.ListEntry != nil {
		typeName = field.ListEntry.ElemType
		fullTypeName = field.ListEntry.ElemFullType
		if oldFD != nil {
			oldMD = oldFD.Message()
		}
	} else if field.MapEntry != nil {
		typeName = field.MapEntry.ValueType
		fullTypeName = field.MapEntry.ValueFullType
		if oldFD != nil {
			if v := oldFD.MapValue(); v != nil {
				oldMD = v.Message()
			}
		}
	} else {
		if oldFD != nil {
			oldMD = oldFD.Message()
		}
	}

	if types.IsWellKnownMessage(fullTypeName) {
		importPath := types.GetWellKnownMessageImport(fullTypeName)
		x.Imports[importPath] = true
	}

	if field.Predefined {
		// import the predefined type's parent filename.
		// NOTE: excludes self.
		if typeInfo := x.typeInfos.GetByFullName(protoreflect.FullName(fullTypeName)); typeInfo != nil &&
			typeInfo.ParentFilename != x.be.GetProtoFilePath() {
			x.Imports[typeInfo.ParentFilename] = true
		}
	} else {
		nestedMsgName := prefix + "." + typeName
		switch {
		case field.Fields != nil:
			// iff field is a map or list and message type is not imported.
			if isSameFieldMessageType(field, x.nestedMessages[nestedMsgName]) {
				// if the nested message is the same as the previous one,
				// just use the previous one, and don't generate a new one.
				return nil
			}
		case !types.IsScalarType(typeName):
			if _, ok := x.nestedMessages[nestedMsgName]; ok {
				// if the nested message has the same name with the previous one,
				// just use the previous one, and don't generate a new one.
				return nil
			}
		default:
			return nil
		}
		// bookkeeping this nested message, so we can check if we can reuse it later.
		x.nestedMessages[nestedMsgName] = field

		// x.g.P("")
		x.p.P(printer.Indent(depth), "message ", typeName, " {")

		x.assignFieldNumbers(field.Fields, oldMD)
		for _, subField := range field.Fields {
			var nestedOldFD protoreflect.FieldDescriptor
			if oldMD != nil {
				nestedOldFD = oldMD.Fields().ByNumber(protoreflect.FieldNumber(subField.GetNumber()))
			}
			if err := x.exportField(depth+1, subField, nestedMsgName, nestedOldFD); err != nil {
				return err
			}
		}
		x.p.P(printer.Indent(depth), "}")
	}
	return nil
}

func genFieldOptionsString(opts *tableaupb.FieldOptions) string {
	jsonName := ""
	// remember and then clear protobuf built-in options
	if opts.Prop != nil {
		jsonName = opts.Prop.JsonName
		opts.Prop.JsonName = ""

		// set nil if field prop is empty
		if IsEmptyFieldProp(opts.Prop) {
			opts.Prop = nil
		}
	}

	// compose this field options
	fieldOpts := "[(tableau.field) = {" + marshalToText(opts) + "}"
	if jsonName != "" {
		fieldOpts += `, json_name="` + jsonName + `"`
	}
	fieldOpts += "]"
	return fieldOpts
}

func marshalToText(m protoreflect.ProtoMessage) string {
	// text := proto.CompactTextString(field.Options)
	bin, err := prototext.Marshal(m)
	if err != nil {
		panic(err)
	}
	// NOTE: remove redundant spaces/whitespace from a string
	// refer: https://stackoverflow.com/questions/37290693/how-to-remove-redundant-spaces-whitespace-from-a-string-in-golang
	text := strings.Join(strings.Fields(string(bin)), " ")
	return text
}

func isSameFieldMessageType(left, right *internalpb.Field) bool {
	if left.GetType() == right.GetType() &&
		left.GetFullType() == right.GetFullType() &&
		len(left.GetFields()) == len(right.GetFields()) {
		for i, l := range left.GetFields() {
			r := right.GetFields()[i]
			if !isSameFieldMessageType(l, r) {
				return false
			}
		}
		return true
	}
	return false
}
