package main

import (
	"flag"
	"fmt"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"text/template/parse"

	"github.com/tableauio/tableau/internal/localizer/i18n"
	"github.com/tableauio/tableau/internal/printer"
	"github.com/tableauio/tableau/internal/strcase"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
	"gopkg.in/yaml.v3"
)

type Config = map[string]i18n.EcodeDetail // ecode -> detail

type FieldDesc struct {
	Name   string
	Type   string
	goName string // name in go style
}

var configPath string
var savePath string

func main() {
	flag.StringVar(&configPath, "config", "", "config file path")
	flag.StringVar(&savePath, "save", "", "save file path")
	flag.Parse()

	config := loadConfig(configPath)
	otherLangConfigs := loadOtherLangConfigs(configPath)

	p := printer.New()
	p.P("// Code generated by internal/tools/cmd/ecode. DO NOT EDIT.")
	p.P("package xerrors")
	p.P()

	sortedKeys := maps.Keys(config)
	sort.Strings(sortedKeys)

	// generate imports
	importMap := map[string]struct{}{}
	for _, item := range config {
		for _, field := range item.Fields {
			if importPath := field.ImportPath(); importPath != "" {
				importMap[importPath] = struct{}{}
			}
		}
	}
	if len(importMap) > 0 {
		imports := maps.Keys(importMap)
		slices.Sort(imports)
		p.P("import (")
		for _, imp := range imports {
			p.P(`"`, imp, `"`)
		}
		p.P(")")
		p.P()
	}

	// generate ecode variables
	for _, name := range sortedKeys {
		item := config[name]
		p.P("var Err", name, " = newEcode(\"", name, "\", `", item.Desc, "`)")
	}
	// generate ecode functions
	for _, name := range sortedKeys {
		detail := config[name]
		extractedFieldNames := extractFieldNames(detail)
		var fds []*FieldDesc
		for _, field := range detail.Fields {
			ok := field.Validate()
			if !ok {
				panic("invalid field")
			}
			fds = append(fds, &FieldDesc{
				Name: field.Name(),
				Type: field.Type(),
			})
			// check current language config
			if !slices.Contains(extractedFieldNames, field.Name()) {
				panic(fmt.Sprintf("field %s not found in extracted fields %s", field.Name(), extractedFieldNames))
			}
		}
		for _, fieldName := range extractedFieldNames {
			if !slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
				return fd.Name == fieldName
			}) {
				fds = append(fds, &FieldDesc{
					Name: fieldName,
					Type: "any", // default
				})
			}
			// assure field names equality in other language configs
			for langPath, otherLangConfig := range otherLangConfigs {
				if otherDetail, ok := otherLangConfig[name]; ok {
					if !slices.Contains(extractFieldNames(otherDetail), fieldName) {
						panic(fmt.Sprintf("%s: field %s not found in other language config %s", name, fieldName, langPath))
					}
				}
			}
		}
		genEcode(p, name, detail.Desc, fds)
	}

	if err := p.SaveWithGoFormat(savePath); err != nil {
		panic(err)
	}
}

func loadConfig(path string) Config {
	config := Config{}
	data, err := os.ReadFile(path)
	if err != nil {
		panic(err)
	}
	if err := yaml.Unmarshal(data, config); err != nil {
		panic(err)
	}
	return config
}

func loadOtherLangConfigs(path string) map[string]Config {
	otherLangConfigs := map[string]Config{} // lang path -> Config
	dir := filepath.Dir(path)
	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".yaml" {
			return nil
		}
		if path != configPath {
			otherLangConfigs[path] = loadConfig(path)
		}
		return nil
	})
	if err != nil {
		panic(err)
	}
	return otherLangConfigs
}

func extractFieldNames(detail i18n.EcodeDetail) []string {
	templateStr := detail.Desc + detail.Text + detail.Help
	var fieldNames []string
	tmpl := template.Must(template.New("i18n").Parse(templateStr))
	parsePipeNode := func(node *parse.PipeNode) {
		if len(node.Cmds) > 0 {
			for _, arg := range node.Cmds[0].Args {
				if field, ok := arg.(*parse.FieldNode); ok && len(field.Ident) == 1 {
					if !slices.Contains(fieldNames, field.Ident[0]) {
						fieldNames = append(fieldNames, field.Ident[0])
					}
				}
			}
		}
	}
	var walkNodes func([]parse.Node)
	walkNodes = func(nodes []parse.Node) {
		for _, node := range nodes {
			switch n := node.(type) {
			case *parse.ActionNode:
				parsePipeNode(n.Pipe)
			case *parse.IfNode:
				parsePipeNode(n.Pipe)
				walkNodes(n.List.Nodes)
				if n.ElseList != nil {
					walkNodes(n.ElseList.Nodes)
				}
			default:
				// no need to support *parse.RangeNode, *parse.WithNode or case *parse.ListNode for now
			}
		}
	}
	walkNodes(tmpl.Root.Nodes)
	return fieldNames
}

func genEcode(p *printer.Printer, name, desc string, fds []*FieldDesc) {
	var params []string
	for _, fd := range fds {
		fd.goName = fd.Name
		if fd.Name == "Error" {
			fd.Type = "error"
			fd.goName = "error_"
		} else {
			fd.goName = strcase.New(nil).ToLowerCamel(fd.Name)
		}
		if token.Lookup(fd.goName).IsKeyword() {
			fd.goName += "_"
		}
		params = append(params, fmt.Sprintf("%s %s", fd.goName, fd.Type))
	}
	p.P("// ", name, ": ", desc)
	p.P("func ", name, "("+strings.Join(params, ", ")+") error {")
	if slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
		return fd.Name == "Error"
	}) {
		p.P("	if error_ == nil {")
		p.P("		return nil")
		p.P("	}")
	}
	p.P("	return renderEcode(Err", name, ", map[string]any{")
	for _, fd := range fds {
		p.P("		\"", fd.Name, "\": ", fd.goName, ",")
	}
	p.P("	})")
	p.P("}")
}
