package main

import (
	"flag"
	"fmt"
	"go/token"
	"maps"
	"os"
	"regexp"
	"slices"
	"strings"

	"github.com/tableauio/tableau/internal/printer"
	"github.com/tableauio/tableau/internal/strcase"
	"gopkg.in/yaml.v3"
)

type Config = map[string]Body

type Body struct {
	Desc   string  `yaml:"desc"`
	Text   string  `yaml:"text"`
	Help   string  `yaml:"help"`
	Fields []Field `yaml:"fields"`
}

// Field maps field name -> field type
type Field map[string]string

func (f Field) Validate() bool {
	return len(f) == 1 && f.Name() != "" && f.Type() != ""
}

// Name returns the field name.
func (f Field) Name() string {
	for k := range f {
		return k
	}
	return ""
}

// Type returns the field type.
func (f Field) Type() string {
	for _, v := range f {
		return v
	}
	return ""
}

type FieldDesc struct {
	Name   string
	Type   string
	goName string // name in go style
}

var configPath string
var savePath string

func main() {
	flag.StringVar(&configPath, "config", "", "config file path")
	flag.StringVar(&savePath, "save", "", "save file path")
	flag.Parse()

	config := Config{}
	d, err := os.ReadFile(configPath)
	if err != nil {
		panic(err)
	}
	if err := yaml.Unmarshal(d, config); err != nil {
		panic(err)
	}

	p := printer.New()
	p.P("// Code generated by internal/tools/cmd/ecode. DO NOT EDIT.")
	p.P("package xerrors")
	p.P()
	re1 := regexp.MustCompile(`\{\{\.?(.+?)\}\}`)

	for _, name := range slices.Sorted(maps.Keys(config)) {
		item := config[name]
		var fieldNames []string
		matches1 := re1.FindAllStringSubmatch(item.Text, -1)
		for _, m := range matches1 {
			if !slices.Contains(fieldNames, m[1]) {
				fieldNames = append(fieldNames, m[1])
			}
		}
		matches2 := re1.FindAllStringSubmatch(item.Desc, -1)
		for _, m := range matches2 {
			if !slices.Contains(fieldNames, m[1]) {
				fieldNames = append(fieldNames, m[1])
			}
		}
		// TODO: check Fields is in rawFields
		var fds []*FieldDesc
		for _, field := range item.Fields {
			ok := field.Validate()
			if !ok {
				panic("invalid field")
			}
			fds = append(fds, &FieldDesc{
				Name: field.Name(),
				Type: field.Type(),
			})
		}
		for _, fieldName := range fieldNames {
			if slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
				return fd.Name == fieldName
			}) {
				continue
			}
			fds = append(fds, &FieldDesc{
				Name: fieldName,
				Type: "any", // default
			})
		}
		genEcode(p, name, item.Desc, fds)
	}
	p.SaveWithGoFormat(savePath)
}

func genEcode(p *printer.Printer, name, desc string, fds []*FieldDesc) {
	var params []string
	for _, fd := range fds {
		fd.goName = fd.Name
		if fd.Name == "Error" {
			fd.Type = "error"
			fd.goName = "error_"
		} else {
			fd.goName = strcase.New(nil).ToLowerCamel(fd.Name)
		}
		if token.Lookup(fd.goName).IsKeyword() {
			fd.goName += "_"
		}
		params = append(params, fmt.Sprintf("%s %s", fd.goName, fd.Type))
	}
	p.P("// ", name, ": ", desc)
	p.P("func ", name, "("+strings.Join(params, ", ")+") error {")
	if slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
		return fd.Name == "Error"
	}) {
		p.P("	if error_ == nil {")
		p.P("		return nil")
		p.P("	}")
	}
	p.P("	return renderEcode(\"", name, "\", map[string]any{")
	for _, fd := range fds {
		p.P("		\"", fd.Name, "\": ", fd.goName, ",")
	}
	p.P("	})")
	p.P("}")
}
