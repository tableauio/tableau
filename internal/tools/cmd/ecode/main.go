package main

import (
	"flag"
	"fmt"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/tableauio/tableau/internal/localizer/i18n"
	"github.com/tableauio/tableau/internal/printer"
	"github.com/tableauio/tableau/internal/strcase"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
	"gopkg.in/yaml.v3"
)

type Config = map[string]i18n.EcodeDetail // ecode -> detail

type FieldDesc struct {
	Name   string
	Type   string
	goName string // name in go style
}

var configPath string
var savePath string

func main() {
	flag.StringVar(&configPath, "config", "", "config file path")
	flag.StringVar(&savePath, "save", "", "save file path")
	flag.Parse()

	config := loadConfig(configPath)
	otherLangConfigs := loadOtherLangConfigs(configPath)

	p := printer.New()
	p.P("// Code generated by internal/tools/cmd/ecode. DO NOT EDIT.")
	p.P("package xerrors")
	p.P()

	sortedKeys := maps.Keys(config)
	sort.Strings(sortedKeys)

	// generate ecode variables
	for _, name := range sortedKeys {
		item := config[name]
		p.P("var Err", name, " = newEcode(\"", name, "\", `", item.Desc, "`)")
	}
	// generate ecode functions
	for _, name := range sortedKeys {
		detail := config[name]
		extractedFieldNames := extractFieldNames(detail)
		var fds []*FieldDesc
		for _, field := range detail.Fields {
			ok := field.Validate()
			if !ok {
				panic("invalid field")
			}
			fds = append(fds, &FieldDesc{
				Name: field.Name(),
				Type: field.Type(),
			})
			// check current language config
			if !slices.Contains(extractedFieldNames, field.Name()) {
				panic(fmt.Sprintf("field %s not found in extracted fields %s", field.Name(), extractedFieldNames))
			}
		}
		for _, fieldName := range extractedFieldNames {
			if !slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
				return fd.Name == fieldName
			}) {
				fds = append(fds, &FieldDesc{
					Name: fieldName,
					Type: "any", // default
				})
			}
			// assure field names equality in other language configs
			for langPath, otherLangConfig := range otherLangConfigs {
				if otherDetail, ok := otherLangConfig[name]; ok {
					if !slices.Contains(extractFieldNames(otherDetail), fieldName) {
						panic(fmt.Sprintf("%s: field %s not found in other language config %s", name, fieldName, langPath))
					}
				}
			}
		}
		genEcode(p, name, detail.Desc, fds)
	}

	if err := p.SaveWithGoFormat(savePath); err != nil {
		panic(err)
	}
}

func loadConfig(path string) Config {
	config := Config{}
	data, err := os.ReadFile(path)
	if err != nil {
		panic(err)
	}
	if err := yaml.Unmarshal(data, config); err != nil {
		panic(err)
	}
	return config
}

func loadOtherLangConfigs(path string) map[string]Config {
	otherLangConfigs := map[string]Config{} // lang path -> Config
	dir := filepath.Dir(path)
	filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".yaml" {
			return nil
		}
		if path != configPath {
			otherLangConfigs[path] = loadConfig(path)
		}
		return nil
	})
	return otherLangConfigs
}

func extractFieldNames(detail i18n.EcodeDetail) []string {
	re1 := regexp.MustCompile(`\{\{\.?(.+?)\}\}`)
	var fieldNames []string
	matches1 := re1.FindAllStringSubmatch(detail.Text, -1)
	for _, m := range matches1 {
		if !slices.Contains(fieldNames, m[1]) {
			fieldNames = append(fieldNames, m[1])
		}
	}
	matches2 := re1.FindAllStringSubmatch(detail.Desc, -1)
	for _, m := range matches2 {
		if !slices.Contains(fieldNames, m[1]) {
			fieldNames = append(fieldNames, m[1])
		}
	}
	return fieldNames
}

func genEcode(p *printer.Printer, name, desc string, fds []*FieldDesc) {
	var params []string
	for _, fd := range fds {
		fd.goName = fd.Name
		if fd.Name == "Error" {
			fd.Type = "error"
			fd.goName = "error_"
		} else {
			fd.goName = strcase.New(nil).ToLowerCamel(fd.Name)
		}
		if token.Lookup(fd.goName).IsKeyword() {
			fd.goName += "_"
		}
		params = append(params, fmt.Sprintf("%s %s", fd.goName, fd.Type))
	}
	p.P("// ", name, ": ", desc)
	p.P("func ", name, "("+strings.Join(params, ", ")+") error {")
	if slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
		return fd.Name == "Error"
	}) {
		p.P("	if error_ == nil {")
		p.P("		return nil")
		p.P("	}")
	}
	p.P("	return renderEcode(Err", name, ", map[string]any{")
	for _, fd := range fds {
		p.P("		\"", fd.Name, "\": ", fd.goName, ",")
	}
	p.P("	})")
	p.P("}")
}
