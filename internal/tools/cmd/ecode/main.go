package main

import (
	"flag"
	"fmt"
	"go/token"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/tableauio/tableau/internal/localizer/i18n"
	"github.com/tableauio/tableau/internal/printer"
	"github.com/tableauio/tableau/internal/strcase"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
	"gopkg.in/yaml.v3"
)

type Config = map[string]i18n.EcodeDetail

type FieldDesc struct {
	Name   string
	Type   string
	goName string // name in go style
}

var configPath string
var savePath string

func main() {
	flag.StringVar(&configPath, "config", "", "config file path")
	flag.StringVar(&savePath, "save", "", "save file path")
	flag.Parse()

	config := Config{}
	d, err := os.ReadFile(configPath)
	if err != nil {
		panic(err)
	}
	if err := yaml.Unmarshal(d, config); err != nil {
		panic(err)
	}

	p := printer.New()
	p.P("// Code generated by internal/tools/cmd/ecode. DO NOT EDIT.")
	p.P("package xerrors")
	p.P()
	re1 := regexp.MustCompile(`\{\{\.?(.+?)\}\}`)

	sortedKeys := maps.Keys(config)
	sort.Strings(sortedKeys)

	// generate ecode variables
	for _, name := range sortedKeys {
		item := config[name]
		p.P("var Err", name, " = newEcode(\"", name, "\", `", item.Desc, "`)")
	}
	// generate ecode functions
	for _, name := range sortedKeys {
		item := config[name]
		var fieldNames []string
		matches1 := re1.FindAllStringSubmatch(item.Text, -1)
		for _, m := range matches1 {
			if !slices.Contains(fieldNames, m[1]) {
				fieldNames = append(fieldNames, m[1])
			}
		}
		matches2 := re1.FindAllStringSubmatch(item.Desc, -1)
		for _, m := range matches2 {
			if !slices.Contains(fieldNames, m[1]) {
				fieldNames = append(fieldNames, m[1])
			}
		}
		// TODO: check Fields is in rawFields
		var fds []*FieldDesc
		for _, field := range item.Fields {
			ok := field.Validate()
			if !ok {
				panic("invalid field")
			}
			fds = append(fds, &FieldDesc{
				Name: field.Name(),
				Type: field.Type(),
			})
		}
		for _, fieldName := range fieldNames {
			if slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
				return fd.Name == fieldName
			}) {
				continue
			}
			fds = append(fds, &FieldDesc{
				Name: fieldName,
				Type: "any", // default
			})
		}
		genEcode(p, name, item.Desc, fds)
	}
	err = p.SaveWithGoFormat(savePath)
	if err != nil {
		panic(err)
	}
}

func genEcode(p *printer.Printer, name, desc string, fds []*FieldDesc) {
	var params []string
	for _, fd := range fds {
		fd.goName = fd.Name
		if fd.Name == "Error" {
			fd.Type = "error"
			fd.goName = "error_"
		} else {
			fd.goName = strcase.New(nil).ToLowerCamel(fd.Name)
		}
		if token.Lookup(fd.goName).IsKeyword() {
			fd.goName += "_"
		}
		params = append(params, fmt.Sprintf("%s %s", fd.goName, fd.Type))
	}
	p.P("// ", name, ": ", desc)
	p.P("func ", name, "("+strings.Join(params, ", ")+") error {")
	if slices.ContainsFunc(fds, func(fd *FieldDesc) bool {
		return fd.Name == "Error"
	}) {
		p.P("	if error_ == nil {")
		p.P("		return nil")
		p.P("	}")
	}
	p.P("	return renderEcode(Err", name, ", map[string]any{")
	for _, fd := range fds {
		p.P("		\"", fd.Name, "\": ", fd.goName, ",")
	}
	p.P("	})")
	p.P("}")
}
